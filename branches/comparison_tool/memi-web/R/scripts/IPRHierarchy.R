# This code contains the functions needed to handle the collapsing of IPR (which may be useful
# to extract relevant information) during the pre-processing of the data.
# Note: If ths code comes to be used with the comparison tool, replace paths by absolute paths. 

# Read the hierarchy file, line by line.  If the file is not found, the program stops running.
hierarchyFile <- readLines("R/ressources/ParentChildTreeFile.txt")


CreateHierarchyList <- function(level) {
  # Create a hierarchy list from the 'hierarchyFile'. Each element of this list is composed of four
  # things: the IPR, its description, its position in 'hierarchyFile' and all the corresponding
  # children terms.  
  # Args: 
  #   level: the desired level for the IPR list (minimum 1, maximum 5).
  # 
  # Returns: 
  #   The hierarchy list of a certain level containing all the needed information for collapsing.
  
  # Error handling: if the 'level' is not between 1 and 5, stop.
  if ((level < 1) | (level > 5)) {
    stop("Incorrect level. Try again.")
  }
  
  # Hyphen handling (see structure of 'hierarchyFile')
  hyphens <- ""
  hyphens <- rep("--", (level - 1))
  hyphens <- paste(hyphens, collapse = "")
  
  # Useful regular expressions, to the rescue!
  searchPattern <- paste("^", hyphens, "IPR\\d{6}", sep = "")  # Reg. exp. to match parents
  childrenPattern <- paste("^", hyphens, "-{2,}IPR\\d{6}", sep = "")  # Reg. exp. to match children
  descPattern <- paste(searchPattern, "::.+::", sep = "")  # Reg. exp. to match descriptions
  
  # Grab the parents and children terms
  grabbedIPR <- regmatches(hierarchyFile, regexpr(searchPattern, hierarchyFile))
  grabbedIPR <- gsub(hyphens, "\\1", grabbedIPR)
  grabbedChildren <- regmatches(hierarchyFile, regexpr(childrenPattern, hierarchyFile))
  grabbedChildren <- gsub(paste(hyphens, "-{2,}", sep = ""), "\\1", grabbedChildren)
  
  # Grab the descriptions and delete the '::' before and after (dirty).
  desc <- regmatches(hierarchyFile, regexpr(descPattern, hierarchyFile))
  desc <- gsub(searchPattern, "\\1", desc)
  desc <- regmatches(desc, regexpr("([[:alnum:]]|\\s|-|/|\\+|\\(|\\))+", desc))
  
  # Grab the index of parents and children.
  parentsIndex <- grep(searchPattern, hierarchyFile, value = FALSE)
  childrenIndex <- grep(childrenPattern, hierarchyFile, value = FALSE)
  
  # Creation of the list, which is empty at first
  hierarchyList <- list()
  
  # Fill the list with all needed information
  for (i in 1:length(parentsIndex)) {
    # Retrieve children
    beginIndex <- parentsIndex[i]
    endIndex <- parentsIndex[i + 1]
    
    if (!is.na(endIndex)) {
      childrenOf <- grabbedChildren[which((childrenIndex > beginIndex) & (childrenIndex < endIndex))]
    } else {
      childrenOf <- grabbedChildren[which(childrenIndex > beginIndex)]
    }
    
    # Store children in a single string
    childrenString <- ""
    childrenString <- paste(childrenOf, collapse = "|")
    
    # Creation of the actual element of the list + appending it to the list
    newElmt <- c()
    newElmt <- c(grabbedIPR[i], parentsIndex[i], desc[i], childrenString)
    hierarchyList[[i]] <- newElmt
  }
  
  # Return the finished list
  return(hierarchyList)
}


CreateHierarchyString <- function(hierarchyList) {
  # Create a hierarchy string from a 'hierarchyList'. It only contains index of parents IPR
  # followed by their children terms, all in a single string. It is useful to fasten the collapsing
  # during the pre-processing of the data.  
  # Args: 
  #   hierarchyList: an IPR hierarchy list generated by the 'CreateHierarchyList' function.  
  #
  # Returns: 
  #   A string containing index of parents IPR followed by their children terms.
  hierarchyString <- ""
  for (i in 1:length(hierarchyList)) {
    # The 'sep' argument can be replaced by anything you prefer.
    hierarchyString <- paste(hierarchyString, '--',hierarchyList[[i]][1], ':', hierarchyList[[i]][4], sep = "")
  }
  return(hierarchyString)
} 

